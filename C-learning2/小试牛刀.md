<font size = 4 face = "黑体">

<a href="#将三个数按从大到小输出">1、将三个数按从大到小输出</a>

<a href="#打印3的倍数的数">2、打印3的倍数的数</a>

<a href="#最大公约数">3、最大公约数</a>

<a href="#打印1000年到2000年之间的闰年">4、打印1000年到2000年之间的闰年</a>

<a href="#写一个代码：打印100~200之间的素数">5、写一个代码：打印100~200之间的素数</a>

<a href="#求1!+2!+...+n!，要求使用单层循环">6、求1!+2!+...+n!，要求使用单层循环</a>

<a href="#二分查找">7、二分查找</a>

<a href="#9*9口发表">8、9*9口发表</a>

<a href="#交换两个整数的内容">9、交换两个整数的内容</a>

<a href="#递归方式实现打印一个整数的每一位">10、递归方式实现打印一个整数的每一位</a>

<a href="#1+2+...+n用递归实现">11、1+2+...+n用递归实现</a>

<a href="#阶乘的递归实现">12、阶乘的递归实现</a>

<a href="#阶乘的非递归实现">13、阶乘的非递归实现</a>

<a href="#strlen的模拟（递归实现、非递归）">14、strlen的模拟（递归实现、非递归）</a>

<a href="#字符串逆序（递归实现）">15、字符串逆序（递归实现）</a>

<a href="#计算一个数的每位之和（递归实现）">16、计算一个数的每位之和（递归实现）</a>

<a href="#递归实现n的k次方">17、递归实现n的k次方</a>

<a href="#计算第n个斐波那契数">18、计算第n个斐波那契数（递归和非递归）</a>

<a href="#交换数组">19、交换数组</a>

<a href="#数组操作">20、数组操作</a>

<a href="#冒泡排序">21、冒泡排序</a>

<a href="#交换两个变量（不创建临时变量）">22、交换两个变量（不创建临时变量）</a>

<a href="#封装函数统计整数二进制位中1的个数">23、封装函数统计整数二进制位中1的个数</a>

<a href="#求整数n，二进制位为1的个数">24、求整数n，二进制位为1的个数</a>

<a href="#根据操作符优先级，判断下面代码的结果是?">25、根据操作符优先级，判断下面代码的结果是?/a>

<a href="#求两个数二进制中不同位的个数">26、求两个数二进制中不同位的个数</a>

<a href="#打印整数二进制的奇数位和偶数位">27、打印整数二进制的奇数位和偶数位</a>

<a href="#字符串逆序（非递归）">28、字符串逆序（非递归）</a>

<a href="#计算求和）">29、计算求和</a>

<a href="#调整奇数偶数顺序">30、调整奇数偶数顺序</a>

<a href="#喝汽水问题">31、喝汽水问题</a>

<a href="#杨辉三角">32、杨辉三角</a>

<a href="#猜凶手">33、猜凶手</a>

<a href="#猜名次">34、猜名次</a>

<a href="#字符串旋转结果">35、字符串旋转结果</a>

<a href="#字符串左旋">36、字符串左旋</a>

<a href="#定义一个返回值是函数指针的函数指针">37、定义一个返回值是函数指针的函数指针</a>

<a href="#声明一个数组指针，指向的数组的每个元素是一个函数指针">38、声明一个数组指针，指向的数组的每个元素是一个函数指针</a>

<a href="#杨氏矩阵">39、杨氏矩阵</a>




<a id="将三个数按从大到小输出"></a>

##### 将三个数按从大到小输出

```c
#include <stdio.h>
int main() {
    int a, b, c, max = 0, mid = 0, min = 0;
    scanf("%d %d %d", &a, &b, &c);
    max = a > b ? (a > c ? a : c) : (b > c ? b : c);
    min = a < b ? (a < c ? a : c) : (b < c ? b : c);
    mid = (a != max && a != min) ? a : ((b != max && b != min) ? b : c);
    printf("%d %d %d", max, mid, min);
    return 0;
}
```
选择排序的思想

```c
#include <stdio.h>
int main() {
    int a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    if (a < b) {
        a ^= b;
        b ^=  a;
        a ^= b;
    }
    if (a < c) {
        a ^= c;
        c ^= a;
        a ^= c;
    }
    if (b < c) {
        b ^= c;
        c ^= b;
        b ^= c;
    }
    printf("%d %d %d", a, b, c);
    return 0;
}
```

<a id="打印3的倍数的数"></a>
##### 打印3的倍数的数

```c
#include <stdio.h>
int main() {
    short n = 3;
    while (n <= 100) {
        printf("%d ", n);
        n += 3;
    }printf('\n');
    return 0;
}
```

<a id="最大公约数"></a>
##### 最大公约数

辗转相除

```c
#include <stdio.h>
typedef int ty;
ty Max_common_divisor(int a, int b) {
    ty max = a > b ? a : b;
    ty min = a < b ? a : b;
    ty tmp = 0;
    while (max % min != 0) {
        tmp = a % b;
        max = min;
        min = tmp;
    }
    return min;
}
int main() {
    ty a = 0, b = 0;
    scanf("%d %d", &a, &b);
    printf("%d", Max_common_divisor(a, b));
    return 0;
}
```

<a id="打印1000年到2000年之间的闰年"></a>
##### 打印1000年到2000年之间的闰年

```c
#include <stdio.h>
void leap_year() {
    for (int i = 1000; i <= 2000; ++i) {
        if (i % 4 == 0 && i % 100 != 0 || i % 400 == 0) {
            printf("%d ", i);
        }
    }
}
int main() {
    leap_year();
    return 0;
}
```



<a id="写一个代码：打印100~200之间的素数"></a>
##### 写一个代码：打印100~200之间的素数

所有自然数可以用集合A = { 6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5 }表示，其中 n >= 0，显然，子集B = {6n, 6n+2, 6n+3, 6n+4}内的元素都不是素数，所以num可以表示成6n+1和6n+5可能是素数，如果6i+1和6i+5是num的因子就不为素数

```c
#include <stdbool.h>
#include <stdio.h>
#include <math.h>
bool isprime(int num) {
    if (num == 2 || num == 3)
        return true;
    //不和6的倍数相邻的数不是素数
    if (num % 6 != 1 && num % 6 != 5)
        return false;
    //6i+1和6i+5是num的因子,就不为素数
    int half = (unsigned int)sqrt(num);
    for (int i = 5; i <= half; i += 6)
    {
        if (num % i == 0 || num % (i + 2) == 0)
            return false;
    }
    return true;
}
#include <stdio.h>
int main() {
    for (int i = 100; i <= 200; ++i) {
        if (isprime(i))
            printf("%d ", i);
    }
    return 0;
}
```





<a id="求1!+2!+...+n!，要求使用单层循环"></a>
##### 求1!+2!+...+n!，要求使用单层循环

```c
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
int main() {
    int n = 0;
    int sum = 0;
    while (scanf("%d", &n) == 1) {
        sum = 1;
        int* arr = (int*)malloc(sizeof(int) * n);
        arr[0] = 1;
        for (int i = 1; i < n; ++i) {
            arr[i] = arr[i - 1] * (i+1);
            sum += arr[i];
        }
        printf("%d\n", sum);
    }
    return 0;
}
```

上面的空间占用比较大，可以不记录n！(1...n)的阶乘值

```c
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
int main() {
    int n = 0;
    int sum = 0;
    while (scanf("%d", &n) == 1) {
        sum = 1;
        int tmp = 1;
        for (int i = 1; i < n; ++i) {
            tmp *= (i + 1);
            sum += tmp;
        }
        printf("%d\n", sum);
    }
    return 0;
}
```

<a id="二分查找"></a>
##### 二分查找

[left, right)左闭右开方式

```c
//二分查找
//1 2 3 4 5 6 7 8 9 10
#include <stdio.h>
int main() {
    int data[10] = { 0 };
    int find = 0;
    for (int i = 0; i < 10; ++i)
        data[i] = i + 1;
    printf("请输入要查找的数字:>\n");
    scanf("%d", &find);
    int left = 0;
    int right = sizeof(data) / sizeof(int);
    //[left, right)左闭右开方式
    while (left < right) {
        int mid = (left + right) >> 1;
        if (data[mid] < find)
            left = mid + 1;
        else if (data[mid] > find)
            right = mid;
        else {
            printf("%d找到了，下标是%d\n", data[mid], mid);
            break;
        }
    }
    printf("找不到\n");
    return 0;
}
```

[left, right]左闭右闭方式

```c
//二分查找
//1 2 3 4 5 6 7 8 9 10
#include <stdio.h>
int main() {
    int data[10] = { 0 };
    int find = 0;
    for (int i = 0; i < 10; ++i)
        data[i] = i + 1;
    printf("请输入要查找的数字:>\n");
    scanf("%d", &find);
    int left = 0;
    int right = sizeof(data) / sizeof(int)-1;
    //[left, right]左闭右闭方式
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (data[mid] < find)
            left = mid + 1;
        else if (data[mid] > find)
            right = mid - 1;
        else {
            printf("%d找到了，下标是%d\n",data[mid], mid);
            break;
        }
    }
    printf("找不到\n");
    return 0;
}
```

<a id="9*9口发表"></a>
##### 9*9口发表

```c
//9*9
#include <stdio.h>
int main() {
    for (int i = 1; i < 10; ++i) {
        for (int j = 1; j <= i; ++j) {
            printf("%2d*%2d=%2x`d ", j, i, i * j);
        }
        printf("\n");
    }
    return 0;
}
```

##### 12*12口发表

```c
//9*9
#include <stdio.h>
int main() {
    for (int i = 1; i < 13; ++i) {
        for (int j = 1; j <= i; ++j) {
            printf("%2d*%2d=%3d ", j, i, i * j);
        }
        printf("\n");
    }
    return 0;
}
```

<a id="交换两个整数的内容"></a>
##### 交换两个整数的内容

按址传参借助临时变量交换

```c
#include <stdio.h>
#define TYPE int
void swap(TYPE* a, TYPE* b) {
    TYPE tmp = *a;
    *a = *b;
    *b = tmp;
}
int main() {
    TYPE a = 666, b = 998;
    printf("交换前：a=%d, b=%d\n", a, b);
    swap(&a, &b);
    printf("交换后：a=%d, b=%d\n", a, b);
    return 0;
}
```
按址传参不借助临时变量交换

```c
#include <stdio.h>
#define TYPE int
void swap(TYPE* a, TYPE* b) {
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}
int main() {
    TYPE a = 666, b = 998;
    printf("交换前：a=%d, b=%d\n", a, b);
    swap(&a, &b);
    printf("交换后：a=%d, b=%d\n", a, b);
    return 0;
}
```

<a id="递归方式实现打印一个整数的每一位"></a>
##### 递归方式实现打印一个整数的每一位

从右往左

```c
//递归方式实现打印一个整数的每一位
#include <stdio.h>
#define TYPE int
void print_each(TYPE num) {
    if (num <= 0)
        return;
    printf("%d ", num % 10);
    print_each(num / 10);
}
int main() {
    TYPE num = 998;
    print_each(num);
    return 0;
}
```

从左往右


```c
#include <stdio.h>
#define TYPE int
void print_each(TYPE num) {
    if (num <= 0)
        return;
    print_each(num / 10);
    printf("%d ", num % 10);
}
int main() {
    TYPE num = 998;
    print_each(num);
    return 0;
}
```

<a id="1+2+...+n用递归实现"></a>
##### 1+2+...+n用递归实现

没有返回值，使用按址传参的参数接收结果

```c
#include <stdio.h>
void func(int* a, int n) {
    if (n <= 0)
        return;
    *a += n;
    func(a, n - 1);
}
int main() {
    int n = 10;
    int a = 0;
    func(&a, n);
    printf("%d\n", a);
    return 0;
}
```
通过返回值返回结果

```c
#include <stdio.h>
int func(int n) {
    if (n <= 0)
        return 0;
    return n+func(n-1);
}
int main() {
    int n = 10;
    printf("%d\n", func(n));
    return 0;
}
```

n是1的时候就返回1，可以少一次递归深度

```c
#include <stdio.h>
int func(int n) {
    if (n == 1)
        return 1;
    return n+func(n-1);
}
int main() {
    int n = 10;
    printf("%d\n", func(n));
    return 0;
}
```

<a id="阶乘的递归实现"></a>
##### 阶乘的递归实现

```c
#include <stdio.h>
long long int factorial(long long int n) {
    if (n == 1)
        return 1;
    return n * factorial(n - 1);
}
int main() {
    long long int n = 0;
    scanf("%ld", &n);
    printf("%ld", factorial(n));
    return 0;
}
```

<a id="阶乘的非递归实现"></a>
##### 阶乘的非递归实现

```c
#include <stdio.h>
long long int factorial(long long int n) {
    long long int res = 1;
    for (long long int i = 2; i <= n; ++i)
        res *= i;
    return res;
}
int main() {
    long long int n = 0;
    scanf("%ld", &n);
    printf("%d\n", factorial(n));
    return 0;
}
```

<a id="strlen的模拟（递归实现、非递归）"></a>
##### strlen的模拟（递归实现、非递归

递归实现strlen

```c
//递归实现strlen
#include <stdio.h>
int strlen_self(char* ch) {
    if (*ch == '\0')
        return 0;
    return 1 + strlen_self(ch + 1);
}
int main() {
    char st[10] = "ASDFGHJKL";
    printf("%d\n", strlen_self(st));
    return 0;
}
```
非递归实现strlen

```c
//非递归实现strlen
#include <stdio.h>
int strlen_self(char* ch) {
    int sum = 0;
    while (*ch++ != '\0') {
        sum++;
    }
    return sum;
}
int main() {
    char st[10] = "ASDFGHJKL";
    printf("%d\n", strlen_self(st));
    return 0;
}
```

<a id="字符串逆序（递归实现）"></a>
##### 字符串逆序（递归实现）

编写一个函数 reverse_string(char * string)（递归实现）

实现：将参数字符串中的字符反向排列。

要求：不能使用C函数库中的字符串操作函数。

```c
//字符串逆序（递归实现）
#include <stdio.h>
#include <string.h>

void _reverse_string(char* string, int i) {
    if (i >= strlen(string) >> 1)
        return;
    char tmp = *(string+strlen(string)- 1-i);
    *(string + strlen(string) - 1 - i) = *(string+i);
    *(string + i) = tmp;
    _reverse_string(string, i + 1);
}
void reverse_string(char* string) {
   _reverse_string(string, 0);
}
int main() {
    char st[5] = "ASDF";
    reverse_string(st);
    printf("%s\n", st);
    return 0;
}
```
<a href="#字符串逆序（非递归）">字符串逆序（非递归）</a>



注意函数重载是C++才引入的概念

<a id="计算一个数的每位之和（递归实现）"></a>
##### 计算一个数的每位之和（递归实现）

写一个递归函数DigitSum(n)，输入一个非负整数，返回组成它的数字之和

例如，调用DigitSum(1729)，则应该返回1+7+2+9，它的和是19

输入：1729，输出：19

```c
//计算一个数的每位之和（递归实现）
#include <stdio.h>
int DigitSum(n) {
    if (n < 10)
        return n;
    return n%10+DigitSum(n / 10);
}
int main() {
    int n = 0;
    scanf("%d", &n);
    printf("%d\n", DigitSum(n));
    return 0;
}
```

<a id="递归实现n的k次方"></a>
##### 递归实现n的k次方

编写一个函数实现n的k次方，使用递归实现

```c
//递归实现n的k次方
//编写一个函数实现n的k次方，使用递归实现
#include <stdio.h>
int pow(int n, int k) {
    if (k == 1)
        return n;
    return n*pow(n, k - 1);
}
int main() {
    int n, k;
    scanf("%d %d", &n, &k);
    printf("%d\n", pow(n, k));
    return 0;
}
```

<a id="计算第n个斐波那契数"></a>
##### 计算第n个斐波那契数（递归和非递归）

递归和非递归分别实现求第n个斐波那契数

例如：

输入：5  输出：5

输入：10， 输出：55

输入：2， 输出：1


非递归：迭代方式

```c
#include <stdio.h>
int fib(int n) {
    int pre = 0, las = 1, tmp = 0, i = 1;
    while (i++ < n) {
        tmp = pre;
        pre = las;
        las = tmp + las;
    }
    return las;
}
int main() {
    int n = 0;
    while (scanf("%d", &n) == 1) {
        printf("%d\n", fib(n));
    }
    return 0;
}
```

递归：

```c
#include <stdio.h>
int fib(int n) {
    if (n == 1 || n == 2)
        return 1;
    return fib(n - 1) + fib(n - 2);
}
int main() {
    int n = 0;
    while (scanf("%d", &n) == 1)
        printf("%d\n", fib(n));
    return 0;
}
```

<a id="交换数组"></a>
##### 交换数组

将数组A中的内容和数组B中的内容进行交换。（数组一样大）

```c
//交换数组
#define TY int
#include <stdio.h>
void exchange_arr(TY*arr1, TY*arr2) {
    for (int i = 0; i < sizeof(arr1) / sizeof(TY); ++i) {
        arr1[i] ^= arr2[i];
        arr2[i] ^= arr1[i];
        arr1[i] ^= arr2[i];
    }
}
int main() {
    TY arr1[6] = {1, 2, 3, 4, 5, 6};
    TY arr2[6] = {7, 8, 9, 10, 11, 12};
    exchange_arr(arr1, arr2);
    for (int i = 0; i < sizeof(arr1) / sizeof(TY); ++i)
        printf("%d ", arr1[i]);
    printf("\n");
    for (int i = 0; i < sizeof(arr1) / sizeof(TY); ++i)
        printf("%d ", arr2[i]);
    return 0;
}
```

<a id="数组操作"></a>
##### 数组操作

创建一个整形数组，完成对数组的操作

实现函数init() 初始化数组为全0
实现print()  打印数组的每个元素
实现reverse()  函数完成数组元素的逆置。
要求：自己设计以上函数的参数，返回值。



```c
//数组操作
#include <stdio.h>
void init(int *arr, int n) {
    for (int i = 0; i < n; ++i)
        arr[i] = 0;
}
void print(int* arr, int n) {
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    printf("\n");
}
void reverse(int* arr, int n) {
    for (int i = 0; i < n>>1; ++i) {
        arr[i] ^= arr[n - 1 - i];
        arr[n - 1 - i] ^= arr[i];
        arr[i] ^= arr[n - 1 - i];
    }
}
int main() {
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(arr) / sizeof(int);
    print(arr, n);
    reverse(arr, n);
    print(arr, n);
    init(arr, n);
    print(arr, n);
    return 0;
}
```

<a id="冒泡排序"></a>
##### 冒泡排序

```c
#include <stdio.h>
void popSort(int* arr, int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                arr[j] ^= arr[j + 1];
                arr[j+1] ^= arr[j];
                arr[j] ^= arr[j + 1];
            }
        }
    }
}
int main() {
    int arr[] = { 4, 7, 8, 9, 6, 5, 4, 2, 3, 1 };
    int n = sizeof(arr) / sizeof(int);
    popSort(arr, n);
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    return 0;
}
```

增加有序性判断，如若数组已经有序则停止排序

```c
#include <stdio.h>
#include <stdbool.h>
void popSort(int* arr, int n) {
    bool flag = false;
    for (int i = 0; i < n; ++i) {
        flag = true;
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                arr[j] ^= arr[j + 1];
                arr[j+1] ^= arr[j];
                arr[j] ^= arr[j + 1];
                flag = false;
            }
        }
        if (flag)
            return;
    }
}
int main() {
    int arr[] = { 4, 7, 8, 9, 6, 5, 4, 2, 3, 1 };
    int n = sizeof(arr) / sizeof(int);
    popSort(arr, n);
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    return 0;
}
```

<a id="交换两个变量（不创建临时变量）"></a>
##### 交换两个变量（不创建临时变量）

不允许创建临时变量，交换两个整数的内容

采用以异或的方式实现

```c
#include <stdio.h>
void swap(int* a, int* b) {
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}
int main() {
    int a, b;
    scanf("%d%d\n", &a, &b);
    printf("a=%db=%d", a, b);
    swap(&a, &b);
    printf("a=%db=%d\n", a, b);
    return 0;
}
```

如果是C++,swap函数可以使用引用传参的方式


<a id="封装函数统计整数二进制位中1的个数"></a>
##### 封装函数统计整数二进制位中1的个数

写一个函数返回参数二进制中 1 的个数。

比如： 15    0000 1111    4 个 1

```c
#include <stdio.h>
int  NumberOf1(int n) {
    unsigned int tmp = n;
    int sum = 0;
    while (tmp > 0) {
        sum += tmp & 1;
        tmp >>= 1;
    }
    return sum;
}
int main() {
    int n;
    scanf("%d", &n);
    printf("%d", NumberOf1(n));
    return 0;
}
```


<a id="求整数n，二进制位为1的个数"></a>
##### 求整数n，二进制位为1的个数

每次循环取出num的个位，是1计数器就加1，num然后右移一位，循环继续，直到num为0循环结束，缺点只能适于正整数

```c
#include <stdio.h>
int main() {
    int num = 0;
    scanf("%d", &num);
    int count = 0;
    while (num) {
        if (num % 2)
            count++;
        num = num>>1;
    }
    printf("%d", count);
    return 0;
}
```

讲输入的整数都按无符号整形处理，就可以满足正确统计负整数位为一的个数

```c
//可以统计负整数位为一的个数
#include <stdio.h>
int main() {
    int n = 0;
    scanf("%d", &n);
    unsigned int num = n;
    int count = 0;
    while (num) {
        if (num % 2)
            count++;
        num = num >> 1;
    }
    printf("%d", count);
    return 0;
}
```

以上代码都是对整数取个位数及位右移实现的，也可以通过循环比较整数32个位是否为1来实现

```c
#include <stdio.h>
int main() {
    int n = 0;
    scanf("%d", &n);
    unsigned int num = n;
    int count = 0;
    for(int i=0; i<32; ++i){
        if (num & 1<<i)
            count++;
    }
    printf("%d", count);
    return 0;
}
```

<a id=""></a>
##### 根据操作符优先级，判断下面代码的结果是?

```c
#include <stdio.h>
int main()
{
    int i = 1;
    int ret = (++i) + (++i) + (++i);
    printf("ret = %d\n", ret);
    return 0;
}
```

12

```c
#include <stdio.h>
int main()
{
    int i = 10;
    printf("%d %d %d\n", i++, i++, i++);
    i = 10;
    printf("%d %d %d\n", ++i, ++i, ++i);
    return 0;
}
```

12 11 10
13 13 13

VS平台下参数是从右往左传，注意后置++先使用值然后再加价，前置++先加再使用





<a id="求两个数二进制中不同位的个数"></a>
##### 求两个数二进制中不同位的个数

编程实现：两个int（32位）整数m和n的二进制表达中，有多少个位(bit)不同？ 

输入例子:

1999 2299

输出例子:7

<a href="https://www.nowcoder.com/questionTerminal/9c3b8a8d9f1c4ae3b709d04625586225">牛客网的OJ链接</a>

```c
#include <stdio.h>
int main() {
    int m, n;
    int count = 0;
    scanf("%d %d", &m, &n);
    for (int i = 0; i < 32; ++i) {
        if ((m & (1 << i)) ^ (n & (1 << i)))
            count++;
    }
    printf("%d\n", count);
    return 0;
}
```

另一种思路，m^n,然后看为1的位有几个


<a id="打印整数二进制的奇数位和偶数位"></a>
##### 打印整数二进制的奇数位和偶数位

```c
#include <stdio.h>
int main() {
    int n;
    scanf("%d", &n);
    printf("二进制位:");
    for (int i = 0; i < 32; ++i)
        printf("%d", ((1 << i) & n) == 0 ? 0 : 1);
    printf("\n奇数位:");
    for (int i = 0; i < 32; i+=2) 
        printf("%d", ((1 << i) & n) == 0 ? 0 : 1);
    printf("\n偶数位:");
    for (int i = 1; i < 32; i += 2)
        printf("%d", ((1 << i) & n) == 0 ? 0 : 1);
    return 0;
}

```

<a id="字符串逆序（非递归）"></a>
##### 字符串逆序（非递归）

<a href="https://www.nowcoder.com/questionTerminal/cc57022cb4194697ac30bcb566aeb47b">牛客网的OJ链接</a>

可以参考：<a href = "#字符串逆序（递归实现）">字符串逆序（递归实现）</a>

```c
#include <stdio.h>
#include <string.h>
int main() {
    char ch_arr[100] = { 0 };
    char tmp = 0;
    int i = 0;
    while (scanf("%c", &tmp) && tmp!='\n') {
        ch_arr[i++] = tmp;
    }
    for (int i = 0; i < strlen(ch_arr) >> 1; ++i) {
        tmp = ch_arr[i];
        ch_arr[i] = ch_arr[strlen(ch_arr) - 1 - i];
        ch_arr[strlen(ch_arr) - 1 - i] = tmp;
    }
    printf("%s", ch_arr);
    return 0;
}
```

将strlen放入for循环是会造成性能损失的，由于strlen函数是运行时计算字符串长度的，因此要用一个临时变量提前计算好

```c
#include <stdio.h>
#include <string.h>
int main() {
    char ch_arr[100] = { 0 };
    char tmp = 0;
    int i = 0;
    int len = strlen(ch_arr);
    while (scanf("%c", &tmp) && tmp!='\n') {
        ch_arr[i++] = tmp;
    }
    for (int i = 0; i <  len>> 1; ++i) {
        tmp = ch_arr[i];
        ch_arr[i] = ch_arr[len - 1 - i];
        ch_arr[len- 1 - i] = tmp;
    }
    printf("%s", ch_arr);
    return 0;
}
```

<a id="计算求和"></a>
##### 计算求和

求Sn=a+aa+aaa+aaaa+aaaaa的前5项之和，其中a是一个数字，

例如：2+22+222+2222+22222

```c
#include <stdio.h>
int main() {
    int a = 0;
    int res = 0;
    scanf("%d", &a);
    for (int i = 5; i > 0; --i) {
        res += a * i;
        a *= 10;
    }
    printf("%d\n", res);
    return 0;
}
```

<a id="打印水仙花数"></a>
##### 打印水仙花数

求出0～100000之间的所有“水仙花数”并输出。

“水仙花数”是指一个n位数，其各位数字的n次方之和确好等于该数本身，如:153＝1^3＋5^3＋3^3，则153是一个“水仙花数”。

```c
#include <stdio.h>
int main() {
    const int row = 7;
    for (int i = 0; i < row; ++i) {
        for (int j = 0; j < row - i - 1; ++j)
            printf(" ");
        for (int k = 0; k < 2 * i + 1; ++k)
            printf("*");
        printf("\n");
    }
    for (int i = 0; i < row -1; ++i) {
        for (int j = 0; j <= i; ++j)
            printf(" ");
        for (int k = 0; k < 2 * (row-i-1) - 1; ++k)
            printf("*");
        printf("\n");
    }
    return 0;
}
```

类似题目：<a href="https://blog.csdn.net/qq_43808700/article/details/109740132?utm_source=app">牛客C语言入门题库</a>中 ***BC38变种水仙花***



<a id="调整奇数偶数顺序"></a>
##### 调整奇数偶数顺序

题目：

输入一个整数数组，实现一个函数，来调整该数组中数字的顺序使得数组中所有的奇数位于数组的前半部分，所有偶数位于数组的后半部分。


```c

//输入提示：输入多个数字以空格隔开，回车结束输入
// 2 4 6 8 1 3 5 7 9
#include <stdio.h>
int main() {
    int num = 0;
    int size = 0;
    int* space = (int*)malloc(sizeof(int) * size);
    //动态管理空间获取输入
    while (scanf("%d", &num)) {
        size++;
        int* tmp = NULL;
        while ((tmp = (int*)realloc((void*)space, sizeof(int) * size)) == NULL);
        space = tmp;
        space[size - 1] = num;
        if (getchar() != '\n')
            continue;
        else
            break;
    }
    //奇前偶后
    int pre = 0;
    for (int i = 0; i < size; ++i) {
        if (space[i] % 2) {
            if (i == pre)continue;
            space[pre] ^= space[i];
            space[i] ^= space[pre];
            space[pre] ^= space[i];
            pre++;
        }
    }
    //遍历
    for (int i = 0; i < size; ++i)
        printf("%d ", space[i]);
    printf("\n");
    free(space);
    return 0;
}
```



<a id="喝汽水问题"></a>
##### 喝汽水问题


喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水，给20元，可以多少汽水（编程实现）。


一开始 1 元钱可以喝 1 瓶汽水。那么我们用 total 记录喝的瓶数，用 empty 记录空瓶子数。我们一开始有 20 元。那么  total = money = 20 ，empty = money =20 。接下来，两个空瓶子可以换一瓶汽水。那么此时 total = empty =20/2 =10，空瓶子等于empty = empty/2 + empty%2 。不难理解为什么要加模2 的结果。因为如果空瓶子是5瓶，那么可以换4瓶汽水，但是还剩余一个瓶子下次一起换。接下来只要瓶子数量大于等于2.我们这个都可以这样计算，那这就成了一个循环。

```c
#include <stdio.h>
#include<stdlib.h>
 
int main()
{
	int money = 0;
	printf("请输入money=");
	scanf("%d", &money);
	int total = money;
	int empty = money;
	while (empty >= 2)
	{
		total += empty/ 2;
		empty = empty / 2 + empty % 2;
	}
	printf("你可以喝 %d 瓶饮料\n", total);
	system("pause");
	return 0;
}
```



<a id="杨辉三角"></a>
##### 杨辉三角

在屏幕上打印杨辉三角。



1

1 1

1 2 1

1 3 3 1

……


<a href="https://blog.csdn.net/qq_43808700/article/details/109740132?utm_source=app#BC109杨辉三角">请参考牛客网C语言入门题库：BC109杨辉三角</a>




<a id="猜凶手"></a>
##### 猜凶手
猜凶手


日本某地发生了一件谋杀案，警察通过排查确定杀人凶手必为4个嫌疑犯的一个。

以下为4个嫌疑犯的供词:
A说：不是我。
B说：是C。
C说：是D。
D说：C在胡说
已知3个人说了真话，1个人说的是假话。
现在请根据这些信息，写一个程序来确定到底谁是凶手。




先进行简单的分析：

```c
bool a, b, c, d;
//a
a = false;
//b
c = true;
//c
d = true;
//d
d = false;

//假话必然产生于b,c两人中间
//b假cd就矛盾不能同时为真
//所以c是假话，因此不是D,ABD说的都是真话因此就是凶手就是C
d = false;
```

因此：

```c
#include <stdio.h>  
int main(){
    int murder;
    for (murder = 'A'; murder <= 'D'; murder++)
        if (((murder != 'A') + (murder == 'C') + (murder == 'D') + (murder != 'D')) == 3)    //三真一假，在if语句的，括号里为真结果为1，要是假结果为0。因此if括号  后面若成立，必定为三真一假，即必定等于3.  
            printf("murder is %c\n", murder);     //由于最终要输出凶手，为一个字符，%c可用输出字符  
    return 0;
}
```


<a id="猜名次"></a>

##### 猜名次


5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果：



A选手说：B第二，我第三；

B选手说：我第二，E第四；

C选手说：我第一，D第二；

D选手说：C最后，我第三；

E选手说：我第四，A第一；

比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。


```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int a = 0;
    int b = 0;
    int c = 0;
    int d = 0;
    int e = 0;
    for (a = 1; a <= 5; a++)
        for (b = 1; b <= 5; b++)
            for (c = 1; c <= 5; c++)
                for (d = 1; d <= 5; d++)
                    for (e = 1; e <= 5; e++)
                    {
                        if (((b == 1) + (a == 3) == 1) &&
                            ((b == 2) + (e == 4) == 1) &&
                            ((c == 1) + (d == 2) == 1) &&
                            ((c == 5) + (d == 3) == 1) &&
                            ((e == 4) + (a == 1) == 1) == 1)
                        {
                            printf("a=%d b=%d c=%d d=%d e=%d \n", a, b, c, d, e);
                        }
                    }
    return 0;
}
```




<a id="字符串旋转结果"></a>

##### 字符串旋转结果




写一个函数，判断一个字符串是否为另外一个字符串旋转之后的字符串。



例如：给定s1 =AABCD和s2 = BCDAA，返回1

给定s1=abcd和s2=ACBD，返回0.



AABCD左旋一个字符得到ABCDA

AABCD左旋两个字符得到BCDAA

AABCD右旋一个字符得到DAABC



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
//左旋函数
void left_reverse(char* goal) {
    char tmp = goal[0];
    strncpy(goal, goal+1, strlen(goal)-1);
    goal[strlen(goal) - 1] = tmp;
}
//判断一个字符串是否为另外一个字符串旋转之后的字符串
bool is_reversed(const char* a, const char* b) {
    if (strlen(a) != strlen(b))
        return false;
    char* tmp = NULL;
    while ((tmp = (char*)calloc(strlen(a) + 1, sizeof(char))) == NULL);
    strcpy(tmp, a);
    for (size_t i = 0; i < strlen(a); ++i) {
        left_reverse(tmp);
        if (!strcmp(tmp, b))
            return true;
    }
    return false;
}
int main() {
    char s1[] = "AABCD"; 
    char s2[] = "BCDAA";
    printf("%s\n", is_reversed(s1, s2)==1?"true":"false");
    return 0;
}
```


<a id="字符串左旋"></a>

##### 字符串左旋




实现一个函数，可以左旋字符串中的k个字符。

例如：

ABCD左旋一个字符得到BCDA

ABCD左旋两个字符得到CDAB


```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
//左旋函数
void left_reverse(char* goal) {
    char tmp = goal[0];
    strncpy(goal, goal+1, strlen(goal)-1);
    goal[strlen(goal) - 1] = tmp;
}
int main() {
    int k = 0;
    printf("输入旋转k个字符：");
    scanf("%d", &k); //输入旋转k个字符
    char S[] = "ABCD";
    printf("旋转之前：%s\n", S);
    while (k--)
        left_reverse(S);
    printf("旋转之后：%s\n", S);
    return 0;
}
```


<a id="定义一个返回值是函数指针的函数指针"></a>

##### 定义一个返回值是函数指针的函数指针



定义一个函数指针，指向的函数有两个int形参并且返回一个函数指针，返回的指针指向一个有一个int形参且返回int的函数？

    int (*(*F)(int, int))(int)



<a id="声明一个数组指针，指向的数组的每个元素是一个函数指针"></a>

##### 声明一个数组指针，指向的数组的每个元素是一个函数指针



声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*



    int (*(*p)[10])(int *)




<a id="杨氏矩阵"></a>

##### 杨氏矩阵

有一个数字矩阵，矩阵的每行从左到右是递增的，矩阵从上到下是递增的，请编写程序在这样的矩阵中查找某个数字是否存在。

要求：时间复杂度小于O(N);

```c
#include <stdio.h>
#include <stdbool.h>
//线性搜索算法
bool step_wise(int arr[][5], int row, int col, int find) {
    int r=0, c=col-1;
    while (r < row && c >= 0) {
        if (find == arr[r][c])
            return true;
        else if (find < arr[r][c])
            --c;
        else if (find > arr[r][c])
            ++r;
    }
    return false;
}
//二分思想：从对角线开始查找
bool diagonal_search(int arr[][5], int row, int col, int find) {
    int r = 0, c = 0;
    while (r < row && c < col) {
        if (find == arr[r][c])
            return true;
        else if (find < arr[r][c]) { //小于当前，就从上方或者左边查询
            for (int i = r; i >= 0; --i) //搜索上方
                if (arr[i][c] == find)
                    return true;
            for (int i = c; i >= 0; --i) //搜索左边
                if (arr[r][i] == find)
                    return true;
        }
        else if (find > arr[r][c]) {
            ++r;
            ++c;
        }
    }
    return false;
}
int main() {
    //给定杨氏矩阵
    int arr[5][5] = {
        {1,	4,	7,	11,	15,},
        {2,	5,	8,	12,	19,},
        {3,	6,	9,	16,	22,},
        {10,13,	14,	17,	24,},
        {18,21,	23,	26,	30 }
    };
    int find = 13; //要搜索的元素
    printf("%s\n", step_wise(arr, 5, 5, find) == true ? "true" : "false");
    printf("%s\n", diagonal_search(arr, 5, 5, find)==true? "true":"false");
    return 0;
}
```

</font>