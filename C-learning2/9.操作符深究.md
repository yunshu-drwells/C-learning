<font size = 4 face = "黑体">



<a href="#算术操作符"> 算术操作符</a>

<a href="#移位操作符"> 移位操作符</a>

<a href="#位操作符"> 位操作符</a>

<a href="#赋值操作符"> 赋值操作符</a>

<a href="#单目操作符"> 单目操作符</a>

<a href="#关系操作符"> 关系操作符</a>

<a href="#逻辑操作符"> 逻辑操作符</a>

<a href="#条件操作符"> 条件操作符</a>

<a href="#逗号表达式"> 逗号表达式</a>

<a href="#数组下标引用、函数调用和结构成员访问操作符"> 数组下标引用、函数调用和结构成员访问操作符</a>



<a id="算术操作符"></a>

#### 算术操作符

\+ - * / %

以上算数操作符都是双目操作符，只需要注意的是<font color ="#FF0000">取模运算符两个操作数都必须是整数，除法操作符只要至少有一个操作数是浮点数则按浮点数计算</font>，否则执行整数除法

---

<a id="移位操作符"></a>

#### 移位操作符

<< 左移操作符

\>> 右移操作符

移位操作符也全是双目操作符，左操作数代表要操作的值（可以是整数变量也可以是常量），右操作数只需要清楚两点，<font color ="#00FF00">位操作是对补码进行的位操作，左移高位抛弃右边补零，右移低位丢弃高位补符号位相同的数字</font>

---

<a id="位操作符"></a>

#### 位操作符

|符号|作用|计算规则|
|:---|:---|:---|
|& |按位与|同为1才得1|
|\| |按位或|有一个1就得1|
|^ |按位异或|相同得0相异得0|

<font color ="#0000FF">位操作符还是双目操作符，是对补码进行的位操作</font>

###### 应用

通过异或操作符可以不通过临时变量交换两个变量的值：参考<a href="https://blog.csdn.net/qq_43808700/article/details/110261799?utm_source=app">小试牛刀</a>中 ***22、交换两个变量（不创建临时变量）***


通过位操作符移位操作可以统计整数二进制中1的个数：参考<a href="https://blog.csdn.net/qq_43808700/article/details/110261799?utm_source=app">小试牛刀</a>中 ***24、求整数n，二进制位为1的个数***


---

<a id="赋值操作符"></a>

#### 赋值操作符


##### 单赋值=

赋值操作符 = 是双目操作符，给左操作数赋右操作数的值

###### 应用

连续赋值比如：

    int a = 10;
    int x = 0;
    int y = 20;
    a = x = y+1;

<font color ="#FFFF00">注意：连续赋值是从右往左赋值的一个过程</font>

##### 复合赋值



|符号|计算规则|
|:---|:---|
| += |左操作数等于左操作数加右操作数的值|
| -= |左操作数等于左操作数减右操作数的值|
| *= |左操作数等于左操作数乘右操作数的值|
| /= |左操作数等于左操作数除右操作数的值|
| %= |左操作数等于左操作数模右操作数的值|
| >>=|左操作数等于左操作数右移右操作数个位之后的值|
| <<=|左操作数等于左操作数左移右操作数数个位之后的值|
| &= |左操作数等于左操作数按位与右操作数的值|
| |= |左操作数等于左操作数按位或右操作数的值|
| ^= |左操作数等于左操作数按位异或右操作数的值|

<font color ="#00FFFF">复合赋值操作符也全是双目操作符，复合赋值操作符简化了的a=a()b;这样前两个操作数相同的赋值表达式书写方式</font>

a = a+b;就可以写成a+=b;


---

<a id="单目操作符"></a>

#### 单目操作符

|符号|作用|
|:---|:---|
|! |逻辑反操作
|- |负值
|+ |正值
|& |取地址
|sizeof |操作数的类型长度（以字节为单位）
|~ |对一个数的二进制按位取反
|-- |前置、后置--
|++ |前置、后置++
|* |间接访问操作符(解引用操作符)
|(类型) |强制类型转换

单目操作符的操作数都是一个，只需要遵守操作符所能操作的操作数规范，以及正确应用就足够了。这里需要知道的一个小知识就是<font color ="#FF00FF">前置\++的效率高于后置\++</font>，前置\++的效率之所以高于后置\++是因为后置\++实现过程中开辟了一个int临时变量，前置\++则没有，前置后置\--也是如此。

<font color ="#FF00FF">还有需要注意的是，sizeof只能在数组定义的作用域内，使用sizeof统计数组字节大小</font>请参考：<a href ="https://blog.csdn.net/qq_43808700/article/details/110873214?utm_source=app">6.函数与递归</a> 中 ***函数传参*** 部分内容



---

<a id="关系操作符"></a>

#### 关系操作符

|符号|作用|
|:---|:---|
| >   |用于测试“大于”
| <   |用于测试“小于”
| >=  |用于测试“不小于”
| <=  |用于测试“不大于”
| !=  |用于测试“不相等”
| ==  |用于测试“相等”

以上关系操作符操作数都是需要两个，最终的表达式真值不是真就是假，结果是符合二项分布的


---


<a id="逻辑操作符"></a>

#### 逻辑操作符


&& 逻辑与

\|| 逻辑或

###### 应用

逻辑操作符常用于逻辑判断语句，比如while、if、for中

注意：<font color ="#C0C0C0">逻辑与前后都为真才为真，否则为假，</font> <font color ="#00FFFF"> 特别注意如果逻辑与连接的表达式从左往右第一个就为假那么表达式整个就已经为假，表达式的值直接就返回了，因此程序不会继续往后判断。</font>
<font color ="#C0C0C0">逻辑或前后操作数只要有一个是真整个逻辑或构成的表达式的值就为真。</font>同时还有区分按位与&与按位或|操作符的区别

例：360一道笔试题，考的就是逻辑与从左往右碰到第一个为假的表达式，就无需往后继续判断整个逻辑与连接的表达式的值就为假了

```c
#include <stdio.h>
int main()
{
    int i = 0,a=0,b=2,c =3,d=4;
    i = a++ && ++b && d++;
    //i = a++||++b||d++;
    printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
    return 0;
}
//程序输出的结果是什么？a=1 b=2 c=3 d=4
```

---


<a id="条件操作符"></a>

#### 条件操作符

exp1 ? exp2 : exp3

三目操作符exp1 ? exp2 : exp3很明显需要三个操作数，第一个操作数exp1是一个条件判断语句，真值是真就执行表达式exp2，否则执行表达式exp3


###### 应用

1、<a href="https://blog.csdn.net/qq_43808700/article/details/110261799?utm_source=app">小试牛刀</a>中 ***将三个数按从大到小输出***

2、<a href="https://blog.csdn.net/qq_43808700/article/details/109740132?utm_source=app">牛客C语言入门题库</a>中 ***BC100有序序列合并***

只要注意嵌套使用的层次不要太多



---


<a id="逗号表达式"></a>

#### 逗号表达式

exp1, exp2, exp3, …expN


逗号表达式，就是用逗号隔开的多个表达式。 逗号表达式，从左向右依次执行。整个表达式的结果是最
后一个表达式的结果。

举个栗子：

```c
#include <stdio.h>
int main() {
    int a = 1;
    int b = 2;
    int c = (a > b, a = b + 10, a, b = a + 1);//逗号表达式
    printf("a=%d,b=%d,c=%d\n", a, b, c);
    return 0;
}
```

上面代码最终的执行结果a，b，c分别是多少？

注意逗号表达式，是是从左往右执行的，最终整个表示的返回值就是最后一个逗号后面的表达式的值

因此手动计算：a=12,b=13,c=13，通过验证，结果也是相同的



---


<a id="数组下标引用、函数调用和结构成员访问操作符"></a>

#### 数组下标引用、函数调用和结构成员访问操作符




##### 函数调用

请观看<a href="https://blog.csdn.net/qq_43808700/article/details/110873214?utm_source=app">6.函数与递归</a>



##### 函数调用、下标引用和结构成员访问操作符


<a href="https://blog.csdn.net/qq_43808700/article/details/109900714">3.循环和操作符</a> 这篇博文中 ***下标引用、函数调用和结构成员*** 部分讲解过下标引用和结构体成员访问

总结：

简单说，定义一个结构体x，则可以用x.访问结构体成员，使用一个结构子指针p_x指向这个结构体x，则可以使用p_x->访问结构体成员

</font>