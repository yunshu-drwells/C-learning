<font size = 4 face = "黑体">

#### C语言常见关键字：


 auto  break  case  char  const  continue  default  do  double  else  enum extern  float  for  goto  if  int  long  register  return  short  signed sizeof  static  struct  switch  typedef  union  unsigned  void  volatile while


#### extern 

**1. extern用于声明外部变量**

<img src = "https://img-blog.csdnimg.cn/20201121174150624.png">

test.c:

    int num = 998;
    
    
    
main.c:

    #include <stdio.h>
    extern int num;
    int main() {
    	printf("%d\n", num);
    	return 0;
    }


    
extern用于声明外部变量，这样就可以跨文件访问变量


**2. extern用于声明外部函数**


test.c:

    int num = 998;
    
    int max(int a, int b) {
        return a > b ? a : b;
    }

main.c:


    #include <stdio.h>
    extern int num;
    extern int max(int a, int b);
    int main() {
    	printf("%d\n", num);
    	printf("%d\n", max(num, 10000));
    	return 0;
    }
    
extern用于声明外部变量，这样就可以跨文件访问函数


<a id="typedef"></a>

#### typedef 


typedef用于类型重定义，说大白话就是类型重命名

上一篇文章<a href="https://blog.csdn.net/qq_43808700/article/details/109900714?utm-source=app">3.循环和操作符</a>的 . 结构成员访问符的例子就用到了typedef关键字

我们定义一个结构体：

    struct person {
    	int age;
    	char name[10];
    };

结构体实例化时：

    struct person person1 = {17, "denny"};

比较麻烦

因此类型重定义

    typedef struct person {
    	int age;
    	char name[10];
    }person;

定义时：

    person person2 = {18, "freen"};
    
    这样就很方便代码也更简洁


类型重定义之后既可以使用新的类型名，又可以使用重定义之前的类型名定义变量如下：

```c
#include <stdio.h>
typedef struct person {
	int age;
	char name[10];
}person;
int main() {
	struct person person1 = {17, "denny"};
	person person2 = {18, "freen"};
	printf("{%d, %s}\n", person1.age, person1.name);
	printf("{%d, %s}\n", person2.age, person2.name);
	return 0;
}
```


#### static

###### static修饰全局变量

全局变量和static修饰的全局变量比较：

static修饰全局变量改变了链接属性：static修饰全局变量改变了其可见性，只能被该全局变量定义的文件访问


extern用于声明的外部变量不能是静态全局变量，编译会报错




###### static修饰局部变量

static修饰局部变量改变了其生命周期但是并未改变其作用域：static修饰局部变量使其生命周期和整个程序相同，作用域并未改变只能在其局部作用域内被访问到

我们再看上一篇文章<a href="https://blog.csdn.net/qq_43808700/article/details/109900714?utm-source=app">3.循环和操作符</a>就可以知道为什么for循环的例子输出结果使23456了


###### static修饰函数

static修饰函数改变了链接属性：static修饰函数改变了其可见性，只能被该函数定义了的文件访问

extern用于声明的外部函数不能是静态函数，编译也会报错


### 特别注意：

#### define

在C语言中define不是关键字。define是编译器的预编译指令，是编译器实现的，不是C语言的内容

除了define可以定义常量外，还可以定义宏，宏的使用类似于函数，实际宏在预编译阶段 ^[<a href="https://blog.csdn.net/qq_43808700/article/details/109733060?utm_source=app">C语言编译过程</a>]会发生一件事情就是宏替换

    #define ADD1(x, y) x+y
    #define ADD2(x, y) (x+y)
    #include <stdio.h>
    int main()
    {
    	int sum = 0;
    	sum = 10 * ADD1(2, 3);
    	printf("sum = %d\n", sum);
    	sum = 10 * ADD2(2, 3);
    	printf("sum = %d\n", sum);
    	return 0;
    }

以上代码执行后的结果是23 50,原因：宏替换

</font>



#### C语言常见关键字：


 auto  break  case  char  const  continue  default  do  double  else  enum extern  float  for  goto  if  int  long  register  return  short  signed sizeof  static  struct  switch  typedef  union  unsigned  void  volatile while


#### extern 

**1. extern用于声明外部变量**

<img src = "https://img-blog.csdnimg.cn/20201121174150624.png">

test.c:

    int num = 998;
    
    
    
main.c:

    #include <stdio.h>
    extern int num;
    int main() {
    	printf("%d\n", num);
    	return 0;
    }


    
extern用于声明外部变量，这样就可以跨文件访问变量


**2. extern用于声明外部函数**


test.c:

    int num = 998;
    
    int max(int a, int b) {
        return a > b ? a : b;
    }

main.c:


    #include <stdio.h>
    extern int num;
    extern int max(int a, int b);
    int main() {
    	printf("%d\n", num);
    	printf("%d\n", max(num, 10000));
    	return 0;
    }
    
extern用于声明外部变量，这样就可以跨文件访问函数

#### typedef 


typedef用于类型重定义，说大白话就是类型重命名

上一篇文章<a href="https://blog.csdn.net/qq_43808700/article/details/109900714?utm-source=app">3.循环和操作符</a>的 . 结构成员访问符的例子就用到了typedef关键字

我们定义一个结构体：

    struct person {
    	int age;
    	char name[10];
    };

结构体实例化时：

    struct person person1 = {17, "denny"};

比较麻烦

因此类型重定义

    typedef struct person {
    	int age;
    	char name[10];
    }person;

定义时：

    person person2 = {18, "freen"};
    
    这样就很方便代码也更简洁


类型重定义之后既可以使用新的类型名，又可以使用重定义之前的类型名定义变量如下：

```c
#include <stdio.h>
typedef struct person {
	int age;
	char name[10];
}person;
int main() {
	struct person person1 = {17, "denny"};
	person person2 = {18, "freen"};
	printf("{%d, %s}\n", person1.age, person1.name);
	printf("{%d, %s}\n", person2.age, person2.name);
	return 0;
}
```


#### static

###### static修饰全局变量

全局变量和static修饰的全局变量比较：

static修饰全局变量改变了链接属性：static修饰全局变量改变了其可见性，只能被该全局变量定义的文件访问


extern用于声明的外部变量不能是静态全局变量，编译会报错




###### static修饰局部变量

static修饰局部变量改变了其生命周期但是并未改变其作用域：static修饰局部变量使其生命周期和整个程序相同，作用域并未改变只能在其局部作用域内被访问到

我们再看上一篇文章<a href="https://blog.csdn.net/qq_43808700/article/details/109900714?utm-source=app">3.循环和操作符</a>就可以知道为什么for循环的例子输出结果使23456了


###### static修饰函数

static修饰函数改变了链接属性：static修饰函数改变了其可见性，只能被该函数定义了的文件访问

extern用于声明的外部函数不能是静态函数，编译也会报错


### 特别注意：

#### define

在C语言中define不是关键字。define是编译器的预编译指令，是编译器实现的，不是C语言的内容

除了define可以定义常量外，还可以定义宏，宏的使用类似于函数，实际宏在预编译阶段 ^[<a href="https://blog.csdn.net/qq_43808700/article/details/109733060?utm_source=app">C语言编译过程</a>]会发生一件事情就是宏替换

    #define ADD1(x, y) x+y
    #define ADD2(x, y) (x+y)
    #include <stdio.h>
    int main()
    {
    	int sum = 0;
    	sum = 10 * ADD1(2, 3);
    	printf("sum = %d\n", sum);
    	sum = 10 * ADD2(2, 3);
    	printf("sum = %d\n", sum);
    	return 0;
    }

以上代码执行后的结果是23 50,原因：宏替换

</font>







auto 
break 
case 
char 
const 
continue 
default 
do 
double 
else 
enum
extern 
float 
for 
goto 
if 
int 
long 
register 
return 
short 
signed
sizeof 
static 
struct 
switch 
typedef 
union 
unsigned 
void 
volatile
while
