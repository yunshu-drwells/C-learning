<font size = 4 face = "黑体">

<a href="#浮点数的存储">浮点数的存储</a>


<a href="#整数在内存中的存储">整数在内存中的存储</a>


<a id="浮点数的存储"></a>

#### 浮点数的存储



![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115161749173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODA4NzAw,size_16,color_FFFFFF,t_70)

IEEE 754规定:对于32位的浮点数，最高的1位是符号位s ,接着的8位是指数E ,剩下的23位为有效数字M。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115161803389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODA4NzAw,size_16,color_FFFFFF,t_70)


对于64位的浮点数，最高的1位是符号位S ,接着的11位是指数E ,剩下的52位为有效数字M。




可以通过<a href="https://blog.csdn.net/qq_43808700/article/details/109731511?utm_source=app">IEEE-754例题</a>进行巩固知识



S符号标志位，E阶码，M是尾数


```math
浮点数的真值 = (-1)^s × 1.M × 2^e
```

<a id="整数在内存中的存储"></a>

#### 整数在内存中的存储


整数在内存中计算都是以补码的形式进行的


关于原码、反码、补码变换的知识：原码除符号位其它位全取反的到反码，反码+1得到补码

关于原反补变换和数值表达范围的知识请参考<a href="https://blog.csdn.net/qq_43808700/article/details/109905989">char类型原码反码补码移码</a>博文



</font>